import casadi.*

% options needed for the Simulink example
if ~exist('simulink_opts','var')
    disp('using empty simulink_opts to generate solver without simulink block')
    simulink_opts = [];
end

check_acados_requirements()

%% solver settings
N = 40;              % Aumenté el horizonte para swing-up
T = 2.0;             % [s] Aumenté el tiempo de predicción
x0 = [0; pi; 0; 0];  % Estado inicial: [p, θ, v, ω] - péndulo abajo

%% model dynamics
model = model_cart_pole();
nx = length(model.x);  % state size = 4
nu = length(model.u);  % input size = 1

%% OCP formulation object
ocp = AcadosOcp();
ocp.model = model;

%% IMPORTANTE: Usar costo de forma explícita, no con variables extraídas
% Definir las expresiones de costo directamente usando model.x y model.u
% No crear nuevas variables p, theta, etc.

% Pesos para estados transformados: [p, sin(θ), cos(θ)-1, v, ω]
W_p = 1e-2;          % posición
W_sin = 1e3;         % sin(theta)
W_cos = 1e3;         % cos(theta)-1
W_v = 1e-2;          % velocidad lineal
W_omega = 1e-2;      % velocidad angular
W_u = 1e-2;          % control

% ========== COSTO INICIAL (stage 0) ==========
% Solo control en el costo inicial para flexibilidad
ny_0 = nu;
ocp.cost.cost_type_0 = 'LINEAR_LS';  % Más simple para etapa inicial
ocp.cost.W_0 = W_u;
ocp.cost.yref_0 = 0;  % Queremos control = 0 inicialmente
ocp.cost.Vx_0 = zeros(ny_0, nx);
ocp.cost.Vu_0 = 1;

% ========== COSTO PATH (stages 1 to N-1) ==========
% Usar NONLINEAR_LS para el swing-up
ny = 5 + nu;
ocp.cost.cost_type = 'NONLINEAR_LS';
ocp.cost.W = diag([W_p, W_sin, W_cos, W_v, W_omega, W_u]);
ocp.cost.yref = zeros(ny, 1);

% Definir la expresión del costo en términos de model.x y model.u
ocp.model.cost_y_expr = (
    model.x(1),                   
    sin(model.x(2)),               
    cos(model.x(2)) - 1,          
    model.x(3),                    
    model.x(4),                  
    model.u                       
);

% ========== COSTO TERMINAL (stage N) ==========
ny_e = 5;
ocp.cost.cost_type_e = 'NONLINEAR_LS';
ocp.cost.W_e = diag([1e-1, 5e3, 5e3, 1e-1, 1e-1]);  % Más peso en ángulo terminal
ocp.cost.yref_e = zeros(ny_e, 1);

ocp.model.cost_y_expr_e = vertcat(...
    model.x(1),                    % p
    sin(model.x(2)),               % sin(theta)
    cos(model.x(2)) - 1,           % cos(theta) - 1
    model.x(3),                    % v
    model.x(4)                     % ω
);

%% constraints
% Límites de control (fuerza realista)
F_max = 80;  % N

% Usar restricciones de caja
ocp.constraints.constr_type = 'BGH';

% Restricciones de CONTROL
ocp.constraints.idxbu = 0;  % índice 0 para el primer (y único) control
ocp.constraints.lbu = -F_max;
ocp.constraints.ubu = F_max;

% Límites de estado - para swing-up necesitamos permitir movimiento completo
p_max = 2.0;              % m - rango de posición
theta_max = 10*pi;        % rad - permitir múltiples rotaciones para swing-up
v_max = 10.0;             % m/s - velocidad máxima para swing-up
omega_max = 20*pi;        % rad/s - velocidad angular máxima para swing-up

% Para etapas de trayectoria (1 a N-1) - relajadas para swing-up
ocp.constraints.idxbx = 0:nx-1;  % [0, 1, 2, 3] para 4 estados
ocp.constraints.lbx = [-p_max; -theta_max; -v_max; -omega_max];
ocp.constraints.ubx = [p_max; theta_max; v_max; omega_max];

% Para etapa terminal (N) - relajadas también
ocp.constraints.idxbx_e = 0:nx-1;
ocp.constraints.lbx_e = [-p_max; -pi; -v_max; -omega_max];  % Permite cualquier ángulo terminal
ocp.constraints.ubx_e = [p_max; pi; v_max; omega_max];

% Para etapa inicial (0) - fijar el estado inicial
ocp.constraints.idxbx_0 = 0:nx-1;
ocp.constraints.lbx_0 = x0;
ocp.constraints.ubx_0 = x0;

%% Configuración inicial para el solver
% Inicializar con trayectoria de swing-up simple
ocp.solver_options.initialize_t_slacks = 1;
ocp.solver_options.sim_method_num_steps = 10;  % Más pasos para integración
ocp.solver_options.sim_method_num_stages = 4;  % RK4

%% solver options
ocp.solver_options.N_horizon = N;
ocp.solver_options.tf = T;
ocp.solver_options.nlp_solver_type = 'SQP';  % SQP para swing-up
ocp.solver_options.integrator_type = 'ERK';  % Runge-Kutta explícito
ocp.solver_options.qp_solver = 'PARTIAL_CONDENSING_HPIPM';
ocp.solver_options.hessian_approx = 'GAUSS_NEWTON';
ocp.solver_options.qp_solver_cond_N = 5;
ocp.solver_options.qp_solver_warm_start = 2;
ocp.solver_options.qp_solver_mu0 = 1e2;  % Reducido para swing-up
ocp.solver_options.nlp_solver_max_iter = 200;  % Más iteraciones para swing-up
ocp.solver_options.qp_solver_iter_max = 100;
ocp.solver_options.print_level = 1;
ocp.solver_options.ext_fun_compile_flags = '-O2 -fPIC';
ocp.solver_options.globalization = 'MERIT_BACKTRACKING';

% Tolerancias más relajadas para swing-up
ocp.solver_options.nlp_solver_tol_stat = 1e-3;
ocp.solver_options.nlp_solver_tol_eq = 1e-3;
ocp.solver_options.nlp_solver_tol_ineq = 1e-3;
ocp.solver_options.nlp_solver_tol_comp = 1e-3;

ocp.simulink_opts = simulink_opts;
ocp.code_export_directory = 'c_generated_code';

%% create solver
fprintf('\n=== Creando solver de Acados ===\n');

try
    ocp_solver = AcadosOcpSolver(ocp);
    fprintf('✓ Solver creado exitosamente\n');
    
    % Test inicial - CORREGIDO: solve() no devuelve output
    fprintf('\n=== Test del solver ===\n');
    
    % Establecer estado inicial
    ocp_solver.set('constr_x0', x0);
    
    % Resolver el OCP
    ocp_solver.solve();  % No capturar output
    
    % Obtener el estado del solver
    status = ocp_solver.get('status');
    
    if status == 0
        fprintf('✓ Convergió exitosamente\n');
        
        % Obtener y mostrar la solución
        fprintf('\n=== Solución obtenida ===\n');
        
        % Control en el primer paso
        u_opt = ocp_solver.get('u', 0);
        fprintf('Control inicial: F = %.3f N\n', u_opt);
        
        % Estados en algunos puntos de la trayectoria
        fprintf('\nTrayectoria predicha:\n');
        fprintf('Paso\tp [m]\ttheta [rad]\tv [m/s]\tomega [rad/s]\tF [N]\n');
        
        for i = 0:min(5, N-1)
            x_i = ocp_solver.get('x', i);
            if i < N-1
                u_i = ocp_solver.get('u', i);
                fprintf('%d\t%.3f\t%.3f\t%.3f\t%.3f\t\t%.3f\n', i, x_i(1), x_i(2), x_i(3), x_i(4), u_i);
            else
                fprintf('%d\t%.3f\t%.3f\t%.3f\t%.3f\t\t-\n', i, x_i(1), x_i(2), x_i(3), x_i(4));
            end
        end
        
        % Estado terminal
        x_N = ocp_solver.get('x', N);
        fprintf('\nEstado terminal (N=%d):\n', N);
        fprintf('p = %.3f m, theta = %.3f rad (%.1f°), v = %.3f m/s, omega = %.3f rad/s\n', ...
                x_N(1), x_N(2), rad2deg(x_N(2)), x_N(3), x_N(4));
                
    elseif status == 1
        fprintf('⚠ Alcanzó máximo de iteraciones\n');
        
        % Aún así, mostrar lo que haya convergido
        u_opt = ocp_solver.get('u', 0);
        fprintf('Control obtenido: F = %.3f N\n', u_opt);
        
    else
        fprintf('✗ No convergió (status = %d)\n', status);
        
        % Intentar obtener más información
        sqp_iter = ocp_solver.get('sqp_iter');
        time_tot = ocp_solver.get('time_tot');
        fprintf('Iteraciones SQP: %d, Tiempo total: %.3f s\n', sqp_iter, time_tot);
    end
    
catch ME
    fprintf('✗ Error creando o ejecutando solver: %s\n', ME.message);
    
    % Mostrar el stack trace para debugging
    fprintf('\nStack trace:\n');
    for i = 1:length(ME.stack)
        fprintf('  File: %s, Line: %d, Function: %s\n', ...
                ME.stack(i).file, ME.stack(i).line, ME.stack(i).name);
    end
    
    rethrow(ME);
end

%% Función auxiliar para convertir radianes a grados
function deg = rad2deg(rad)
    deg = rad * 180 / pi;
end